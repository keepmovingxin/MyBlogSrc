---
title: Linux常用命令学习
date: 2016-04-28 16:02:52
tags: Linux
categories: 工具
toc: true
---

### 同步时间
以管理员身份执行如下命令，可以自动与网络时间同步：
time.nist.gov 是一个时间服务器`$ rdate -s time.nist.gov`<!--more-->### 管道符： |
就是把前面的命令运行的要放入标准输出的结果丢给后面的命令
`cat 1.txt | cat`
### echo
-n	打印语句后不会换行。-e 开启转义，即可以打印后面的 \t,\r 等转义字符
可以打印彩色文本。
### printf用于格式化输出，使用的参数和C语言中的printf函数一样eg：printf "%-5s %-10s %-4.2f\n" 1 James 80.9968-：表示左对齐，默认为右对齐s：表示打印的是字符串f：表示打印一个浮点数，其中4表示宽度，.2表示保留2位小数printf默认不带换行，需要手动添加
### cat查看文件-n：为每行前面加上行号。-n会为空白行也加上行号，-b选项则会跳过空白行。-s：压缩相邻的空白行，即连续的空白行将压缩为一行。-T：用^I符号表示制表符\t
### 正则表达式由一般字符和特殊字符（meta字符）组成
meta元字符\ 通常用于打开或关闭后续字符的特殊含义，如\(...\)与\{...\}. 匹配任何单个字符（除NULL）\* 匹配前面的子表达式任意次，例：a* 匹配任意多个a? 匹配前面的子表达式零次或一次匹配前面的子表达式一次或多次。\+ 匹配前面的子表达式一次或多次^ 匹配输入字符串的开始位置$ 匹配输入字符串的结束位置[] 匹配方括号内的任一字符，其中可用连字符（-）指的连续字符的范围；^符号若出现在方括号的第一个位置，则表示匹配不在列表中的任一字符(x|y) 匹配x或y，比如：(g|f)ood，匹配good或food### 文件通配符
\* 匹配文件名中的任何字符串，包括空字符串。? 匹配文件名中的任何单个字符。[...] 匹配[ ]中所包含的任何字符。可以用 – 连接，表示范围[!...] 匹配[ ]中非 感叹号！之后的字符。如：5* 5开头的所有字符串*5 5结尾的所有字符串*5? 以5为倒数第二个字符的字符串[0－9] 所有以数字的字符[1,2] 1或者2[!0-9] 不是数字的字符### grep
grep [options] [表达式]1)	[options]列表：	-c	：只输出匹配行的统计数	-n	：显示匹配行及行号
	-A2	：列出匹配行及下面2行
	-B2	：列出匹配行及上面2行
	-C2	：列出匹配行及上下2行
	-I	：不区分大小写(只适用于单字符)
	-h	：查询多文件时不显示文件名	-H	：查询多文件时显示文件名（默认）	-l	：查询多文件时只输出包含匹配字符的文件名	-o	: 每行只输出匹配部分	-s	：不显示不存在或无匹配文本的错误信息	-v	：显示不包含匹配文本的所有行	-r	：递归匹配目录下所有文件及目录	-E	: 扩展grep，增加了额外的正则表达式元字符集	-e	：指定多个匹配样式，样式间“或”的关系	-f pattern_file	：	样式文件pattern_file中逐行存放要匹配的样式，可匹配多个样式，样式之间是“或”的关系	--color	：	为匹配项显示不同颜色
2)	grep –E "pattern1|pattern2" files ：显示匹配 pattern1 或 pattern2 的行
3)	grep –e pattern1 –e pattern2 files : 匹配pattern1或pattern24)	grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行5)	egrep "t_hero|t_item"   匹配t_hero或者t_item的项6)	grep "t_hero\|t_item"	可以实现与上面同样的功能### sedsed [options] 'command' file(s) 或sed [options] -f scriptfile file(s)一次处理一行内容 不改变文件内容[options]列表：
	-n	:	取消默认的输出,使用安静(silent)模式。	-r	:	使用正则表达式，及表达式中不需要进行转义	-f filename :	指定sed脚本的文件名filename	-e '' :	允许多重编辑·  	-i	:	将替换结果应用于源文件1)	替换字符串`sed 's/pattern/string/' file`
或者
`cat file | sed 's/pattern/string/'`2)	替换文件中所有匹配内容，使用参数g`sed 's/pattern/string/g' file`但如果你想从第N处匹配开始替换，可以使用参数/Ng`$ echo thisthisthisthis | sed 's/this/THIS/2g'thisTHISTHISTHIS`3)	sed的定界符'/'.当匹配模式中含有'/'字符时，我们需要用'\'对定界符'/'进行转义`$ echo a/b | sed 's/a\/b/a*b/'a*b`为了避免转义字符造成的理解困难，我们可以使用其它定界符，比如|,:,@,#,$,%,+等等`$ echo a/b | sed 's:a/b:a*b:'a*b`4)	移除匹配样式行  `sed '/pattern/d' file``$ sed -r '/^ *$/d' args.txt		#移除空白行，含有一个或多个空格的行`5)	组合多个表达式```
$ echo abd | sed 's/a/A/' | sed 's/d/D/'  #用管道组合$ echo abd | sed 's/a/A/;s/d/D/'           #用分号组合$ echo abd | sed -e 's/a/A/' -e 's/d/D/'  #用-e选项组合```
6)	已匹配字符串标记（&）&代表匹配给定样式的字符串，常用于对给定样式增加[]，{}等不需要改变样式的情况```$ echo "this is an example" | sed 's/\w\+/[&]/g'   #\w\+ 匹配每个单词[this] [is] [an] [example]
```7)	子串匹配标记（\1）有时我们希望对匹配给定的样式标记出一些子串来，方便后续引用\(pattern\) 用于匹配子串pattern\1 用于引用第一个匹配到的子串，\n 对应第n个匹配到的子串。```$ echo 123 asd | sed 's/\([0-9]\+\) \([a-z]\+\)/\2+\1/' asd+123
```其中\1对应数字123，\2对应字母asd对于子串的引用，在样式里一定要用\(\)括起来，如果加上-r选项，则不需要转义：```$ echo 123 asd | sed -r 's/([0-9]+) ([a-z]+)/\2+\1/'asd+123```8)	引用在脚本中有用的一点，用双引号引用的sed表达式，会对表达式求值来进行扩展，如使用前面定义的变量等```$ text=hello$ echo hello world | sed "s/$text/HELLO/"HELLO world```

### tail用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件主要参数	-f ：	循环读取   #可以用在监控线上有没有报错信息	-q ：	不显示处理信息	-v ：	显示详细的处理信息	-c<数目> ：	显示的字节数	-n<行数> ：	显示行数	--pid=PID ：	与-f合用,表示在进程ID,PID死掉之后结束. 	-q, --quiet, --silent ：	从不输出给出文件名的首部### find
`find dir [option] 'command'`
`dir`: 目录名，用空格隔开多个目录
1) [option]列表：

	-name wildcard 文件名，wildcard表示通配符，并非正则式
	    find dir1 dir2 -name '*.c' –print  在目录dir1和dir2中查找文件，并打印路径
	    如果在-name后面紧跟一个-prune，则表示此目录应被修剪
	    find . \( -name ".svn" -prune \) -o –print 表示对于查找的目录，要么修剪掉（.svn），要么打印出来（其他）。
	-iname 忽略名字大小写
	-path 指定目录，如果在-path前面加上 ！ ，则表示忽略此目录，目录名可以使用通配符匹配。
	-type 文件类型
  	  f:普通文件 d:目录 l:符号连接文件 c:字符设备文件 b:块设备文件 p:管道文件
	-size ±nc 查找大于（+）或小于（-）n字节的文件，注意c（charter）
	-mtime ±ndays 文件最近修改时间
	-user,-nouser 文件所有者
	-group,-nogroup 指定文件用户组
	多条件的与（-a）/或（-o）/非（！）
  	  find . \( -name "*.txt" –o –name "*.sh" \) –print
  	  括号两边应该有空格
	-maxdepth n 指定最大目录深度，n=1表示最大为当前目录
	-mindepth n 指定最小目录深度，n=2表示不打印当前目录下的文件
	  -maxdepth和-mindepth应作为find的第三个参数出现，以提高效率

2) 'command'命令列表：

	-print  打印路径名
	-delete 对找到的文件进行删除 
	-exec   对查找到的目标执行某一命令。
	    find ${workdir} -name "$filename" -exec  |grep $uid
 	   -exec 参数后面跟的是bash命令，但只能跟一个命令，如果想执行多个命令，那么可以将多个命令放进一个shell脚本，然后执行这个脚本。
	    bash命令的终止，使用 ';' (分号）来判定，在后面必须有一个 ';'在分号前应该加上转义字符'\'
	    '{}'，使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于bash命令进行处理
	-ok     与-exec类似，只是对查找到符合条件的目标执行一个命令前需要经过确认
### cut
`cut` 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出，必须指定 `-b`、`-c` 或`-f` 标志之一。
主要参数

	-b: 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
	-c: 以字符为单位进行分割。（单个字母等）
	    cut –c2-5 file	，表示将文件file每行的第2-5个字符作为一列显示出来。
	-d: 自定义分隔符，默认为制表符。
	-f: 与-d一起使用，指定显示哪个区域。
	    例子：cat file.txt | cut -d']' -f7；
            cat file.txt | cut -d']' –f4,7；//打印4和7列
            cat file.txt | cut -d']' –f4-7；//打印4到7列
	-n: 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br />范围之内，该字符将被写出；否则，该字符将被排除。
	--complement: 与-f一起使用，指定显示哪个区域的补集。

### sort  排序
`sort`将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按`ASCII`码值进行比较，最后将他们按升序输出。
主要参数：

	-u: 去除重复行
	-r: sort默认的排序方式是升序，如果想改成降序，用此参数
	-o file: 把排序结果输出到文件file，file可以是原文件
	-n: 以数值排序
	-t: 指定间隔符
	-k: 指定域排序，常与-t连用。sort –t ':' –k 2
		在指定域的时候还可细分，比如指定第二个域的第3个字符开始比较，用-k 2.3;
		比如指定第二个域的第3个字符到第二个域的第5个字符进行排序，用-k 2.3,2.5
		比如只指定第二个域的第3个字符进行排序，用-k 2.3,2.3
	-b: 忽略每一行前面的所有空白部分，从第一个可见字符开始比较
	-f: 忽略大小写进行排序### 未完待续...
